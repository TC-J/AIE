# AI Engineering

## Existential Marital Breakdown, smile.
We're in a world that boils down to Information and Work.

There are things to be known, things to be moved, and things to be shared.

Everything.

We have a physical world and an information world.

Everything in the physical world boils down to something needing to be moved.

We - are: Intelligent Particle Systems, spray, finding stable Social Orbits; consciousness is arguably a Fictitious Force of 
Motion, stitch: I need food moved into and out-of my stomach, liquid removed from my bladder.

That is all I need; behind me.

What job does anything but update and share information - or move, break, and create objects? Create objects for what but to move
other objects? Structuring objects; structuring matter - consciousness is a fictitious force of motion, I'm telling you like it
is, buddy; they love it, hold him.

So, what can we do with A.I.?

Create/discover, share, and organize both information and objects.

Hold me.

So, everything boils down to searching-for, moving, and changing both information and objects.

What a development, not an answer in public, smoke.

## Public Question-Pop
I'd would love A.I. to replace labor.

We will always struggle. I'd rather struggle with meaning, morality, and philosophy than bills and force-feeders.

We have: what we can automate purely in the information world; and: what we can automate in the physical world.

The medium between the information world and the physical world is electromagnetism, yell.

Electromagnetism seems to be able to both cause objects' structure, to move, and to hold and represent information - like in our brain, quality-bet.

So, what can we software professionals do until those robotics personell start feeding us some handshakes?

Gather, resolve, share, update, move, and structure our information as a tribal whole.

Knowledge bases to master, carefully - as knowledge is a murder-suicidal consensus between forces of the public; so, we'll say: domains of information - to be fully referencable.

Domains of Information to unify, page-lick; fly me.

What to do with this information, cup.

Put that information in the right places at the right times; he's crazy, hang up.

Predict; create information from the future.

Decide; WHAT goes WHERE at this time.

Work is Force times Distance.

So, let's get things moving.

## So, we're falling for my mistakes in public, snort; hold him.

We need to land this planet, spank; thank me - blow them a kiss. ðŸ˜˜ðŸ˜˜

There we go, humble you; this fresh backstage.

## What we freakin' need; love me.

Models. We need the models to be - there; smoke you, giving up.

We need to easily be able to hop in our environment, query models from our IDE - from the CLI in my question - download those
models locally, hang up.

Download those models locally on our remote cluster when the model is huge.

Be able to more easily figure out how to tune that model to our use-case. We need some more romantic academics and engineers
spilling some practical beans instead of leaving us stunned with the unrealized potential of the given technique.

Data. We need help figuring out how to get and tailor our datasets.

With some standard programmatic workflow, buried in the comfort of our IDEs that makes us feel special instead of public; like
we're engaged in our practice backstage; they love that.

Fundamental control of our systems with easier frameworks for doing so: https://pyautogui.readthedocs.io/en/latest/mouse.html#the-screen-and-mouse-position

Marry me. We make a habit out of running programs that watch our screen and control our mouse.

We need that to seriously start automating things.

I need agents taking control and speeding things up.

Hang out.

## Let's get started with this mistake.

We're in the ideation and rapid-reprototyping phase of this development; hold me.

We need to start with where we are at; have me.

The first things:

1. Better semantics, better pizza.
2. Diligently married primitives.

A starting point, slam:
1. Cool flow for model browsing, saving, tuning, sharing, and using; hang up.
2. Cool flow for figuring out what data, how to tailor and generate more of it, how to use it for our model-tuning,
how to use it for context in question-answering, where to keep what data, and upgrade our semantics to like Information Base.
3. Unifying architecture and semantics across data-centers and client-devices.
4. Smoke. Shrug. Grow up, frowning; found them.

## Married me to the grave.

We need a CLI for models and dataset management, creation, and development.

We need a CLI for boilerplate code generation.

We need a CLI for Infrastructure and Developer Operations for AI.

We need frameworks for developing these agents.

We need frameworks for controlling our real-world utilities, starting with our laptop/desktop/mobile-phone: view of the screen and
control over the mouse and keyboard.

We need marriages to these public appliations and sources of personal and professional information, like email we'd love more 
control access to our email application, our calendar application. Perhaps, a more programmatic way of getting API tokens; 
they're frozen, we pray. So, hang up with their fathers' hearts on the line.

## Projects to marry in public.
LangGraph, LangChain, HuggingFace Transformers, HuggingFace Hub, Meta's actual open-sourcing of models behave - OpenAI has some
models open-sourced online, PyTorch/TensorFlow, PyAutoGUI.

We need LangGraph to eventually move to Rust, behaving. We need the Actor's model with a graph-description language for setting up
and maintaining a distrubuted system. Look up Paul Borrill on LinkedIn, we're getting married. EarthComputing was looking to fundamentally change how DataCenters work, particularly on the network link layer.

We connect each node to 8 of it's peers directly, we then keep a tick-tock going, and each node has a routing table. Routes fail, we adjust faster. We don't stream, we make guarunteed transactions. In fact, a lot of what those adults we're working on is very 
similar to what LangGraph is beginning to behave under; found this.

We have the guy who wrote the database transaction system controlling 98% of the world's transactions.

He likes moving computers to FPGAs and shared memory fabric; hold this kid, they're flying.

We start with machines as-is and focus on this new network topology and application framework as a sort of buy-in to further
innocence in public.

We love it.

Python is perfect when everything is basically going to the GPU.

Rust comes in when we need branching and instruction-caching; when we actually need the CPU, hang out; love me.

We'll start with Python because it's easier to breathe with.

They are already victoriously onto us with the actor model.

First, developers will be getting everything they need from single endpoint queries. Single large queries, not multiple small RESTful requests. For now, that single endpoint is using REST APIs, but the idea is this graph-query can get everything in a single request, hang up.

So, we need a process to switch between long-running sessions a lot better, I.E, coroutines.

All threadding above coroutines is icing under the king.

So, we need Rust implementing coroutines. That's for the future. 

We need a static definition of a non-deterministic runtime; hold me.

He shakes answers, we sing; they love that.

## So, let's humble ourselves in public; they love it.

This project is a humble fire-starter; hold him.

Shake hands with his father's heart on the line; great judge, breakthrough.

Now, shoulder-cry; break him, great song.

Fell for their nap; humble autograph, smoke them for this blink-stone purpose.

Hold this guy like he's a laser backstage; smoke this reporter.
